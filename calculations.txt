this is the breakdown of the start of my attribute additions How each activity is calculated 
after every run /scale fatcor when computing socre
scakle factor is number of attributes in formual or squared
running
acceleration attr determines is acceleration (accel_mps2 = 2.0 + (6.0 - 2.0) * ((accel_attr - 1) / 19) ** 0.8)
pace detemrines the max speed a player can reach (5 + 5*((Pace-1)/19)^0.8)
work_rate detrmines the proportion of actual pace used by players (when they do not have the ball or the locked defender) //later
this is a sliding scale that impacts diffrent areas based on formulas 
        genral play - nothing important getting into positioon etc 
        support - involved in the surrounding play
        acytive - has the ball or their locked tackler 
turning - introduce orientation to a player in degress 90
agil_norm = (agility_attr - 1) / 19.0

    # --- Step 2: Map to lateral acceleration capability (m/s²) ---
    #   Low agility = 3 m/s²; high agility = 8 m/s²
    a_lat_max = 3.0 + (8.0 - 3.0) * agil_norm

    # --- Step 3: Convert lateral acceleration to max turn rate ---
    #   Formula: omega = a_lat / v   (v floored to avoid infinite spin)
    v_eff = max(speed_mps, 1.5)  # 1.5 m/s floor for low-speed turning
    omega_max = a_lat_max / v_eff

    # --- Step 4: Cap at a max "pivot spin" when almost stopped ---
    omega_snap_cap = 6.0  # rad/s (~343°/s)
    omega_max = min(omega_max, omega_snap_cap)
need to implment orientation

jumping reach is attribute + height (anything above height/.375 is in catch zone difficulty of catch zone. )
catch zone laterally is done the same but 1m + height/.375 is there catch radius
this is the max catch zone and the further away a ball is from body the harder the catch (not normalised to factor in that shorter players are generally more co-ordinated and used to catching further away balls)
standing_jump_m = 0.20 + 0.40 * norm(jumping_reach)
running_jump_m = (0.20 + 0.40 * norm(jumping_reach)) + 0.12 * norm(acceleration)
liftedjump=back_(lifter.height/2)+(jumper.height*1.375)

passing_action 
distance = player.y - target.y
desicion engine detremines target(x, y, 1) # z is fixed for passes y is used for range 
technique+passing/2 detrmines range
  range = 10+ 45( norm(passing_attr) * norm(technique_attr)  ) # combined skill 0..1
success is just passing - skill.modifiers
prob_success =  0.1 + 0.9 * ((1.0 - distance/range)* norm(passing_attr))
if prob_success>=random
    continue
   
else 
    error = random-prob_success
    if error % 2 =0 
        error = -error
    misplaced= (error*distance)/3
    target.x = misplaced+x
 ball.pass(location, target)
scope- possible passes scope 

    """
    Returns total passing scope in radians based on technique.
    1   -> pi   (180 degrees)
    20  -> 2pi  (360 degrees)
    """
    return math.pi + (2 * math.pi - math.pi) * norm(technique_attr)
pass types 
flat, max range = 10m , flat_speed = pass_speed/2.5 , success = + 50% 
 spin,  standdard uses normal speed and range
 league max range = 25m  success =+ 25% pass_speed*.75

 pass_speed= 10.0 + 7.0 * norm(passing)*norm(technique)

 handling
 if a pass travels along  inside and your catch-zone a player may attempt to catch 
 to be elgible the pass must be directed at them. on carrier.desicion_making they pick them as the receiver
 or if a defender chooses to defenderai.intercept
 a player knows the the specs of ball.pass and will attempt to be there in time to catch
 a player will turn and catch ball facing it (not passes will be aimed slighlty ahead so a good pass will not make them slow down) (within .75pi of them)

there ability to catch is determiend by 

space = |ball.x - player.x|
if space < .5
    catch_success = 0. 5 + norm(handling)-skill.modifiers
else catch_success =  0.3 + 0.9 (norm(handling)*norm(technique)
 
 if catch_success > random
    return catch

catch_error = random - catch_success

if catch_error < .2
    ball_juggle(player)

else knock-on state


ball juggle is a non-chosen game action state for the player

kicking logic
1. in-play kicking
2. punting penalties/ free kicks
3. goal kicking
4. drop goals
1. in play kicking
kicking range = = 28.0 + 44.0 * norm(kicking_power)
kick_success =  0.1 + 0.9 * ((1.0 - (distance/range)**2)*( 1.0 + 1.0 * kicking-skill.modifiers))

2. 

distance = hypoetenuse (player,target)
kicking range = = 28.0 + 44.0 * norm(kicking_power)
kick_success =  0.1 + 0.9 * ((1.0 - (distance/range)*( 1.0 + 1.0 * kicking-skill.modifiers))

3. kicking range = = 25.0 + 50.0 * norm(kicking_power)
kick_success =  0.1 + 0.9 * ((1.0 - (distance/range)*( 1.0 + 1.0 *(goalkicking-skill.modifiers))

4. kicking range = = 15.0 + 45.0 * norm(kicking_power)

kick_success =  0.1 + 0.9 * ((1.0 - (distance/range)*( 1.0 + 1.0 *(goalkicking*kicking_power)-skill.modifiers))

ok to note about kicking variance also effects bot x and y axis of kicks- tehy will always have the right trajectory so z is taken care of by arcs

if kick_success >= random
    return kickball(location,target)

else 
    kick_error = random - kick_success
 if error % 2 =0 
        error = -error
    misplaced= (error*distance)

    if |error| < .2 
    target(x,y,z) = target(x,y+misplaced,z) # z is always 0 as it is wehre the ball will land 
    retrun kickball(target)

if .2 <= |error| <= .75 
    target(x,y,z) = target(x+misplaced,y+misplaced,z) # z is always 0 as it is wehre the ball will land 
    retrun kickball(target)

if error > .75
    slice(location) # slice is a functio and kcik type where x,y co-ordinate is randomised in range/3 and arc type is  >85 degrees 

kick profiles (new)
    spiral max range (+20%) , speed = +15% , (skill.modifiers)x2 has a midrange arc of about 45 degrees
    grubber arc of -1 degrees - this will effect everything else as bounce logic takes over
    bomb max range -50 % speed -30% , arc is about 70 degrees
    normal / small one is chip so smae. logic 60 degree arc rest normal

    kick_speed  = 20.0 + 18.0 * norm(kicking_power)   #used for all then changed based on type

Set Piece 
assume all attributes are normed
Scrum - stage based 1. Crouch - 2. Bind, 3. Set,4. feed,  5.drive, 6. stable 
its a battle to get the other team to get to greater than |1|
Feeding_team are + and opposing tive team are - 
if score > 1 feeding_team get a pen & <-1 the opposite 
ALL number vars here are rns etc rn-2 = hooker 
assume all stages involves score = a-b but a and b are computed the same for bit teams unless specified
1.   score = (rn-2(leadership)**2)*(rn-1(scrum)+rn-3(scrum))/3
2. score =+  rn-1(scrum*strength)*rn-3(scrum*strength)
3 score =+ (pack_weight/1000)*(rn-1(scrum)+rn-3(scrum))random #random is for the look of the draw at scrum0time
# in addition to making a score a lock_out can occur on set and the ball wil go right to the back and the scrum will end 
#This is reduce a spamming of pens for a dominant Scrum
if random > 0.5
    lock_out
#team tactics  ai will know if it wanst to scrum or not
    if to go channel 1, mixed or leave in until told to use from tactics
4 if tactic = channel 1 will receive own ball out as long as score  > -.75 else they wilkl have to scrum
    if tactic = mixed if score > 0.5 they will scrum if <-.75 they will have to scrum else they will take it out 
 if leave in will only take out if less score -.25>score>-.75 else will scrum

 # 5 drive this is where second rows come in 
 score =+ ((rn-3(scrum*strength*aggression)+rn-1(scrum*strength*aggression)+rn-2(scrum*strength*aggression)/2 + rn-4(determination*strength)+ (rn-5(determination*strength)*1.5)) /5
 after every drive insatnce the checker from feed will run.Note only teh attacking team can end a scrum

 once the feeding team is satisfied about the scrum it becomes stable waiting for the 9 tp pass or 8 to pick 

while scrum is in stable (once per scrum)
    opposing team can counter_shuv 
        this is opposing props who will try to force  into scruming
feeding_scrum= rn-1(strength*weight/150)* rn-3(strength*weight/150)
opposing_scrum= rn-3(aggression*scrum/150)* rn-3(aggression*scrum/150)
score =+ score = feeding_scrum*(random**1/3)- opposing_scrum(random**1/3)

lineout 
# 3 components the throw, the linout and the lift, the catch/contest
#assume norm
x for loaction thorw is back_ (lifter.height/2)+(jumper.height*1.375)-.1 
# assumed all hookers can hit all areas but harder to hit back 
distance is where the catcher will be whether lifted or not  
throw_success = (distance/25)*dart
if success > random
    return throw(location)


else 
    throw_error = random - throw_success
 if error % 2 =0 
        error = -error
    misplaced= ((1+error)**2-1)

    if |error| < .2 
    target(x,y,z) = target(x,y,z+misplaced) # z is always 0 as it is wehre the ball will land 
    retrun throw(target)

if .2 <= |error| <= .75 
    target(x,y,z) = target(x+misplaced,y ,z+misplaced) # z is always 0 as it is wehre the ball will land 
    retrun thorw(target)
    #risk of crroked throw if others contest

linout itselft 
#competition between attacker and defender to find space
desicions and leadership of caller determine call - done later
# phase 0 simple in and out
score # same as scrum
attacking_lineout = back-lifter(teamwork)*frontlifter(teamwork)*jumper(lineout)**2
defending_lineout = back-lifter(teamwork*concentration)*frontlifter(teamwork*concentartion)*jumper(lineout)**2 
score = attacking_lineout(random**1/3)-defending_lineout(random**1/3)

fpr adavance beyond that loop is done at the above score loop is done at the end of 
for phases of linout 
    attacking_lineout= lineout(teamwork*concentration)**1/3
    defending_lineout= lineout(teamwork*concentration)**1/3
    score = attacking_lineout(random**1/3)-defending_lineout(random**1/3)
attacking_lineout = back-lifter(teamwork)*frontlifter(teamwork)*jumper(lineout)**2
defending_lineout = back-lifter(teamwork*concentration)*frontlifter(teamwork*concentartion)*jumper(lineout)**2 
score = attacking_lineout(random**1/3)-defending_lineout(random**1/3)

edge = score **2
if (score > 0) 
defending team lifting_pod, loctaion (x,y,z-edge)
else 
attacking team lifing_pod loaction(x,y,z-edge)

lifting_pod uses simple formula - liftedjump=back_(lifter.height/2)+(jumper.height*1.375)
#however they can sometimes miss their lift and jumper
#before this called linout_timings is called
attacking_timings= backlifterlifter(strength) * jumper(lineouts) 
defending_timings= backlifter(strength*concentration)* jumper(lineouts*anticpation)
if attacking_timings > random **1/3
    continue
if defebding_timings > random**1/3
    continue

# linout calls _ a good caller can read what the oppsooition are bout to do and beat them
# as well as picking the actual call that suits the match_up there call pick can stump the opposition
call_pick = anticipation*leadership*(lineouts**2)
if call_pick > random
    no contest
    #as long as the throw is in the catch zone they will win the ball


driving_maul stages- 1. intitial, 2.transfer,  3.drive
only occurs off lifted lineouts, in_play maul different
1. attacking_team=(backlifter(teamwork*strenghth)+frontlifter(teamwork*strength))/2
defending_team= for (defenders(determination*aggression) )/3          #) up to 3 defenders within 1m of lift
score = attacking_team(random**1/3) - defending_team(random**1/3)
2. transfer= jumper(teamwork)*handling(receiver)
attacking_team= for all players involved * them togethor player(strength*(determination**2)*teamwork)*transfer #then
attacking_team = weightofinvolved/1000*attacking_team*transfer
defending_team_ = for all weightofinvolved/1000*strength*(determination**2)
score += attacking_team*random**1/3 - defending_team*random**1/3

3. drive 
attacking_team = weightofinvolved/1000*strength*(determination**2)
defending_team = weightofinvolved/1000*strength*(determination**2)
score +=  attacking_team*random**1/3 = - defending_team*random**1/3

maul desicions done by attacking team
only happens in drive stage 
based on tactic.maul 
if cautious & score < .25 
    remove
if balanced & score < 0 
    remove
if aggressive & score < .25
    remove
ball will be stuck if score <-.75 no matter what

if socre between .1 < score< -.1 
fpr 3 turns ball will have to be played

for every .1 score the maul will travel 1m forward

if score > .1 the opposition may attempt to pull it down
for all players involved
if random >.95
#new random here
pull_down = (1-score) - random
if pull_down< 0
    legal_collapse(player,score)

legal_collapse 
    x = pull_down*random - (tempremant*determination*work_rate)
    if x > 0 
        legal_collapse = true 
    else penalty to the attack
evasion
#the point oevasion is that it aims to avouid entring an oppnets tackle zone entilery
uses ec=xisting movement and attempt to use agility and speed to beat the marked tackler
if distamce 5 < x ,2 defender.locked to ball holder
    evasion or enter_contact beocme available in ball-holder-desicions 

evasion requires position of ball_holder, locked_defender
random called firt for variance

evasion_success = ball_holder(agility**2*acceleration*flair)*(1+random**2) - locked_defender(balance*concentration*anticpation*positioning)*(1+random**2)
if success > .5 
    successful_evasion()
    locked_defender.state = stepped
elif success > 0
    successful_evasion()
elif 0>success > -0.5
    break (no change)
else ball_holder.state = vulnerable

successful_evasion()
    if random.rounded to 2 significant figures*100 % 2 =0 
        random = -random #this is the og random form 0-1
    evasion_direction = (holder-position.y-locked_defender-position.y)/70 + random
    ball_holder_target_position (x, y+evasion_direction),0
    locked_tackler_target_position((x, y-evasion_direction),0)
        #as well as putting the attacker portntianlyy out of tackle range it puts the defender in the "stepped" state and less likely to make a succesful tackle

tackle
if ball.holder in tackle_radius of defender.locker trigger tackle()
#simple here but we will expand to different tackl types after. a point
score = attacker(footwork*strength*balance)*random**1/2 - defender(tackling*bravery*determination)random**1/2
if score > .5 
    tackle_broken()
    no tackle 
if .2< score < .5 
    passive_tackle()
    can_offload
if -.2 <score <2
    normal_tackle
if -.5 < score < .-2
    dominat_tackle
if score < -.5
    murder()

scoring
scoring raange (x axis to try line)
scoring range = (1+4(acceleration*finishing))
players will dive if there is a they will enter tackle range on their path to line
dive_success =  0.1 + 0.9 * ((1.0 - distance/range)* norm(diving**2*agility*acceleration)) #this is run once at the start of dive and is there number 
#if during the dive an opponent enters the tackle_range it is used here 
if locked_defender 
dive_success =dive_success - defender(tacklng*bravery**2*agreesion)random.random
if dive_success > .2
success
elif -.2 < dive_success <.2
    tackle_success
else in_touch (if within 5m of touch line), held up, knock_on


offloading
can occur when tackle_score >  -.2
runs can_offload 
uses pass logic for radius_and flat_pass for options x execution
can_offload
    tackle_score + random (flair*offloading)
offload_options = same as can pass but with being_tackled state


skill-modifiers
#have not added fatigue or weather or mood yetr but will add later or pregame impacts)
if defender.distnace < 10
fatigue = 100 # fatigue logic added later
pressure = (10-locked.defender.distance)/10 *composure
skill.modifier = ((100-fatigue)/100)*concentration*random.random*pressure
skill.modifier = skill.modifier/2 #normalise it back halfway to being a full 0-1 range
scramble
#if ball is on ground and thre is an opoosing player within 3m and the player is within 5m ensue scramble
scramble_chance= (5-distance_to_ball)/5*bravery*anticipation**2
scarmble-scuccess = attacker.scramble_chance-defender.scramble_chance
attacker wins if + dfender if -
if scramble_succes > |0.5| 
    player wins and is on feet but opposition isnt
else;   
    player wins but ruck ensues


ruck
    can occur from variety of situations (tackle, maul, scramble, dive)
    both tackler and ball.holder are on ground
    if score for whatever is > 0
        tackler.roll required 
            counter is delay  delayed by 2 seconds
    
    if score > 0.5 
        tackler can counter themselves

2 types of counter (jackal and barge)
     jackal
            1 defender v first 2 attackers in ruck (when they arrive else he will win)
            jackal_success = (rucking**2*balance)*(time_in ruck)
            if jackal_success >= 1 
                penalty
            
            barge #stackable of multiple defender
            loop of counter ruckers v defenders similar to maul push
            attacking_team = aggression*rucking*determination*strength + next player
            defending_team = aggression*rucking*determination*strength
            score +=  attacking_team*random**1/3 = - defending_team*random**1/3
            #probably normalise each score

            if within 3 rounds of pushing score < -.5 
                turnover
            else attcaking_team keeps ball

        avoiding the counter
        if an attacker arrives to ruck beopfre defender they will decide see off the clearput
            shut_down= (rucking*aggressionq*weight/150)/time_in_ruck
        if shut_down> 1
            ruck=ruck_state.won

    

phase-play attack
at each phase of play ruck, maul, scrum,linout, open_play of you arent in h action itself you have a place to go
in attack _off the ball determines whether you are at yor demanded position
in open_play attack
    position_incorrect = random(off_the_ball*anticipation*work_rate) /4 
    x_wrong= position_incorect*random*10
    y_wrong= position_incorect*random*10
    if x_wong.round or y_wrong.round % 2 = 0 
    x_wrong or y_worng =* -1
    player.target_location = x+x_wrong, y+ y wrong, 0

in open_play attack
    position_incorrect = random(positioning*anticipation*work_rate) /4 
    x_wrong= position_incorect*random*10
    y_wrong= position_incorect*random*10
    if x_wong.round or y_wrong.round % 2 = 0 
    x_wrong or y_worng =* -1
    player.target_location = x+x_wrong, y+ y wrong, 0


else everything but open_play
    assume players are well drilled and will go top the right places as their target but pace and workrate may stop them from reaching target
phase-play defend
     have a set position to defend based on shape.s tactics
     if not in backfield group formual for being in the right position is 
     position_incorrect = 1- random(marking**2 * concentration*teamwork) /5
     x_wrong= position_incorect*random*10
    y_wrong= position_incorect*random*5
    player.target_location = x+x_wrong, y+ y wrong, 0

backfield players 
    position_incorrect = 1- random(anticipation*positing**2 teamwork) /5
     x_wrong= position_incorect*random*15
    y_wrong= position_incorect*random*15
    player.target_location = x+x_wrong, y+ y wrong, 0


desicions_with_ball

look_to
pass, kick,score  evade, carry, run 
if tactics support a desicion it get 
tactic= .5*vision # playmaker flag gets plus.v to pass #take_less risks is .5 to carry etc

desicion_with_ball 
every desicon a player makes with the  ball  involves the (desicion**2*random)//3
    run_straight 
    check if any players are within 10,20,0 box in fornt of player if not run
    essentially check if line break is on
    choose to skip to running af pick the best desiocn if 0.5
    should_pass
        check_if defnder(s) ahaed of you 
        check if defender ahead of nearest player to you
        alertrantive_pass checker
        run socre for all options pick highest if one over 0.5
        else skip

    kick 
    defenders in front and how far away 
    if > 5m away 
    check if there each kick type is on
    #based on filed positiuon ability tactics
    pick the highest one aif one is above 0.5

if defender is withing <5m 
evasion v carry desision tree 

aside from carry all enter a vulnerable state for one second before and one second after completion of action




